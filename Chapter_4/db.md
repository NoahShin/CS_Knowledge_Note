# 데이터베이스

# 4.1 데이터베이스의 기본

## DBMS, DataBase Management System
![](https://velog.velcdn.com/images/noahshin__11/post/12fdac98-8bac-4bf3-bf07-74967e8abdfe/image.png)
응용프로그램: 노드 , 자바
DMBS : MySQL
데이터베이스: 창고(?)

## 4.1.1 엔터티
![](https://velog.velcdn.com/images/noahshin__11/post/4f02ef82-9309-4f77-9ffd-445dfc526ac0/image.png)

엔터티(entity)는 사람. 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미


#### 약한 엔터티와 강한 엔터티
- 엔터티는 약한 엔터티와 강한 엔터티로 나뉜다. 

- 예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티라고 할 수 있고 건물은 강 한 엔터티라고 할 수 있습니다.

## 4.1.2 릴레이션

- relation 은 디비에서 정보를 구분하여 저장하는 기본 단위.

- 엔터티에 관한 데이터를 디비는 릴레이션 하나에 담아서 관리.

![](https://velog.velcdn.com/images/noahshin__11/post/0e817e82-af21-4554-87b8-e55aad8c90dd/image.png)
위 그림처럼 회원이라는 엔터티가 
디비에서 관리될 때 
릴레이션으로 변화된 것을 볼 수 있다.

릴레이션은 RDBMS 에선 **테이블**
NoSQL 에선 **컬렉션**

## 4.1.3 속성

- Attribute 는 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보. 

"차"가 엔터티라면 
차 넘버, 바퀴 수, 차 색깔, 차종 등 속성

## 4.1.4 도메인
도메인이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합.

ex) 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값는 {남, 녀} 라는 집합.

## 4.1.5 필드와 레코드
![](https://velog.velcdn.com/images/noahshin__11/post/6f07f9f4-8ff0-4e46-9c2b-b667580b071b/image.png)

### 필드타입
(MySQL 기준)

#### 숫자타입
![](https://velog.velcdn.com/images/noahshin__11/post/3e4a4361-cb8f-4870-87fb-d87b98ea1db4/image.png)

#### 날짜 타입
> - **DATE**
날짜 부분은 있지만 시간 부분은 없는 값에 사용됩니다. 
지원되는 범위는 1000-01- 01〜9999-12-31입니다. 
3바이트의 용량을 가집니다.
- **DATETIME**
날짜 및 시간 부분을 모두 포함하는 값에 사용됩니다. 
지원되는 범위는 1000-01-01 00:00:00에서 9999-12-31 23:59:59입니다. 
8바이트의 용량을 가집니다.
- **TIMESTAMP**
날짜 및 시간 부분을 모두 포함하는 값에 사용됩니다. 
1970—01—01 00:00:01 에서 2038- 01-19 03:14:07까지 지원합니다. 
4바이트의 용량을 가집니다.


#### 문자 타입
> - CHAR
예를 들어 CHAR(30)이라면 최대 30글자까지 입력할 수 있습니다.
CHAR는 테이블을 생성할 때 선언한 길이로 고정되며 길이는 0에서 255 사이의 값을 가집니다. 레코드를 저장할 때 무조건 선언한 길이 값으로 ‘고정’해서 저장됩니다.
- VARCHAR
VARCHAR는 가변 길이 문자열입니다. 길이는 0에서 65,535 사이의 값으로 지정할 수 있으며, 입력된 데이터에 따라 용량을 가변시켜 저장합니다. 예를 들어 10글자의 이메 일을 저장할 경우 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 됩니다.
VARCHAR(10000)으로 선언했음에도 말이죠.

그렇기 때문에 지정된 형태에 따라 저장된 CHAR의 경우 검색에 유리하며, 검색을 별로
하지 않고 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋습니다.


#### TEXT 와 BLOB 
>- TEXT는 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 씁니다.
- BLOB은 이미지, 동영상 등 큰 데이터 저장에 씁니다. 그러나 보통은 아마존의 이미지 호 스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR 로 저장합니다.

#### ENUM 과 SET

ENUM과 SET 모두 문자열을 열거한 타입


> - ENUM은 ENUMfx—small’, ‘small’, ‘medium’, ‘large’, ‘x—large’) 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됩니다. ENUM을 이용하면 x-small 등이 0, 1 등으로 매핑되어 메모 리를 적게 사용하는 이점을 얻습니다. ENUM은 최대 65,535개의 요소들을 넣을 수 있습 니다.
- SET은 ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다릅니다.
참고로 ENUM이나 SET을 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수 정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점이 있습니다.


## 4.1.6 관계
![](https://velog.velcdn.com/images/noahshin__11/post/9233bc84-7733-48dd-b0b6-1cbf0e033b43/image.png)
위 그림만 봐서는 아는것도 모르겠다.

### 1:1 
![](https://velog.velcdn.com/images/noahshin__11/post/f4bea9ee-08db-423b-9b6d-e270bffea196/image.png)

### 1:N
![](https://velog.velcdn.com/images/noahshin__11/post/398fda3f-8ae9-4461-9dd4-d6887dc190da/image.png)

### N:M
![](https://velog.velcdn.com/images/noahshin__11/post/f0c5a6bd-d0c0-4eec-9ae8-e0cd81da4dc1/image.png)

## 4.1.7 키 
![](https://velog.velcdn.com/images/noahshin__11/post/69479560-dcf8-471a-8f6e-10556fdc2733/image.png)

### 기본키 PK 
당연히 중복 안됨

기본키는 자연키 또는 인조키 중에 골라 설정.

> **자연키**
예를 들어 유저 테이블을 만든다고 가정하면 주민등록번호, 이름, 성별 등의 속성이 있습 니다. 이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 남는 것은 주민 등록번호입니다. 이런 식으로 중복된 값들을 제외하며 중복되지 않는 것을 ‘자연스레’ 뽑 다가 나오는 키를 자연키라고 합니다. 자연키는 언젠가는 변하는 속성을 가집니다.

> 인조키
예를 들어 유저 테이블을 만든다고 했을 때 회원 테이블을 생성한다고 가정하면 주민등록 번호, 이름, 성별 등의 속성이 있습니다. 여기에 인위적으로 유저 아이디를 부여합니다. 이를 통해 고유 식별자가 생겨납니다. 오라클은 sequence, MySQL은 auto increment 등 으로 설정합니다. 이렇게 인위적으로 생성한 키를 인조키라고 합니다. 자연키와는 대조적 으로 변하지 않습니다. 따라서 보통 기본키는 인조키로 설정합니다.


### 외래키 FK

![](https://velog.velcdn.com/images/noahshin__11/post/11dc4de2-da92-4c11-83f1-4236e80f916d/image.png)

**후보키**
후보키 (candidate key)는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족 하는 키입니다.

**대체키**
대체키(alternate key)는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말합니다.

**슈퍼키**
슈퍼키(super key)는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.



# 4.2 ERD 와 정규화 과정

- ERD 는 디비 구축할 때 가장 기초적인 뼈대 역할
- 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 피룡한 경우에 **설계도** 역할

## 4.2.3 정규화 과정

### 제 1 정규형
릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 합니다. 
릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 됩니다. 
만약에 반복 집합이 있다면 제거해야 합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/f5e4ee7e-ed29-4860-8ac4-30222de9a570/image.png)


### 제 2 정규형
- 릴레이션이 제1정규형이면서
- 부분 함수의 종속성을 제거한 형태

부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것 을 말합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/59f05133-f1ad-44f4-90b4-924c06ff1032/image.png)

### 제 3 정규형

- 제2정규형이면서 
- 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태

> **이행적 함수 종속**
이행적 함수 종속이란 A — B와 B — C가 존재하면 논리적으로 A — C가 성립하는데, 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/c3ef878f-c0d8-4dbb-ba6d-69a3d0285282/image.png)

### 보이스/코드 정규형 Boyce–Codd normal form (이해 불가)
보이스/코드 정규형(BCNF)은 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말합니다.
(뭔말이여)

![](https://velog.velcdn.com/images/noahshin__11/post/c71e1929-7c48-49a7-a9f2-bf70322f4ee5/image.png)

> 예시)
• 각 수강명에 대해 한 학생은 오직 한 강사의 강의만 수강한다.
• 각 강사는 한 수강명만 담당한다.
• 한 수강명은 여러강사가담당할수있다.

![](https://velog.velcdn.com/images/noahshin__11/post/57705ae1-8ab6-4a4f-aa0f-51b9bcde0951/image.png)


![](https://velog.velcdn.com/images/noahshin__11/post/4910b195-f5bf-416b-8742-37a58d34689c/image.png)
 즉, 강사 속성이 결정자이지만 후보키가 아니므로 이 강사 속성을 분리해야 합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/ed13ceb2-220d-4943-ac94-f6e22257dc65/image.png)


# 4.3 트랜잭션과 무결성

> - 디비에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 디비에 접근하는 방법은 쿼리이므로, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말함
- ACID ! 

## 원자성 “all or nothing”
 
> 원자성(atomicity)은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하 는 특징입니다. 
예를 들어 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이 후에 모두 수행되지 않음을 보장하는 것을 말합니다.


### 커밋과 롤백
커밋(commit)은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어입니다. 

트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말합니다. 

“커밋이 수행 되었다.”를 “하나의 트랜잭션이 성공적으로 수행되었다.”라고도 말합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/c70b4d59-343e-4e9c-a090-76df63277ac4/image.png)
이러한 커밋과 롤백 덕에 데이터의 무결성이 보장됩니다. 

또한, 데이터 변경 전에 변경 사 항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있습니다.

#### 트랜잭션 전파
트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 합니다.

하지만 이를 매번 넘겨주기가 어렵기도 하고 귀찮기도 하죠. 

이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 합니다.

=============== ⚠️ 자바 ⚠️ ===============
![](https://velog.velcdn.com/images/noahshin__11/post/d2e359f7-cced-489b-a263-f45d8341de46/image.png)
 앞의 코드처럼 Spring 프레임워크에서는 ©Transactional 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리합니다.

## 일관성
일관성(consistency)은 ‘허용된 방식’으로만 데이터를 변경해야 하는 것을 의미합니다. 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 합니다. 

## 격리성

격리성(isolation)은 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말합니다. 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 합니다. 그냥 순차적으로 하면 쉽게 되겠지만 그렇게 하면 성능이 나쁘겠죠?
격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/4bed63f1-d9bc-4aba-aa7e-b90d8bef190d/image.png)


> REPEATABLE_READ는 팬텀 리드, 
READ_COMMITTED는 팬텀 리드, 반복 가능하 지 않은 조회가 발생하며. 
READ_UNCOMMITTED는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생할수도 있습니다.

### 팬텀 리드
팬텀 리드(phantom read)는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다.
예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 해봅시다. 
이 결과로 세 개의 테이블이 조회한다고 해보죠. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입합니다. 그러면 그다음 세 개가 아닌 네 개의 테이블이 조회되는 것이죠.

### 반복 가능하지 않은 조회
반복 가능하지 않은 조회(non-repeatable read)는 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킵니다. 
예를 들어 사용자 A가 큰돌의 보석 개수가 100개라는 값을 가진 데이터였는데, 그 이후 사용자 B가 그 값을 1로 변경해서 커밋했다고 하면 사용자 A는 100이 아닌 1을 읽게 됩니다.
팬텀 리드와 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 **다른 행이 선택될 수도 있다는 것**을 의미합니다.

### 더티 리드
더티 리드(dirty read)는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 **‘커밋되지 않은’** 행의 데이터를 읽을 수 있을 때 발생합니다. 예를 들어 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 **‘커밋되지 않은’** 상태라도 그 이후 사용자 B가 조회한 결과가 1로 나오는 경우를 말합니다.

## 격리 수준

### SERIALIZABLE
SERIALIZABLE은 말 그대로 트랜잭션을 순차적으로 진행시키는 것을 말합니다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없습니다. 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 합니다. 그렇기 때문에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준입니다.

### REPEATABLE_READ
REPEATABLE_READ는 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않습니다. 따라서 이후에 추가된 행이 발견될 수도 있습니다.

### READ_COMMITTED
READ_COMMITTED는 가장 많이 사용되는 격리 수준이며 MySQL8.0, PostgreSQL, SQL Server, 오라클에서 **기본값으로 설정**되어 있습니다. READ UNCOMMITTED와 는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없습니다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용합니다.
하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있습니다. 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있습니다. 이 때문에 트랜잭션 A가 같 은행을 다시 읽을때 다른내용이 발견될 수 있습니다.

### READ_UNCOMMITTED
READ_UNCOMMITTED 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이 전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠릅니다. 이는 데이터 무결성을 위해 **되도록이면 사용하지 않는 것**이 이상적이나. 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 ‘어림잡아’ 집계하는 데는 사용하면 좋습니다.

## 지속성

지속성(durability)은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미. 
이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공.
![](https://velog.velcdn.com/images/noahshin__11/post/b9499a64-ac42-4070-ad8f-b7682e7cb03d/image.png)


# 4.4 데이터베이스의 종류
MySQL 제일 인기 많음

C, C++로 만들어졌으며 MylSAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기 반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공합니다. 대용량 데 이터베이스를 위해 설계되어 있고 롤백, 거밋, 이중 암호 지원 보안 등의 기능을 제공하며 많은 서비스에서 사용합니다.

### MySQL의 스토리지 엔진 아키텍처

![](https://velog.velcdn.com/images/noahshin__11/post/c293b3f5-46f4-4e16-9dad-4c57b0a0565d/image.png)

> 데이터베이스의 심장과도 같은 역할을 하는 곳이 바로 스토리지 엔진인데, 
모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점을 두고 있습니다.
스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용할 수 있습니다.
또한, MySQL은 쿼리 캐시를 지원해서 입력된 쿼리문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시합니다.



### PostgreSQL
MySQL 다음으로 잘 나감
![](https://velog.velcdn.com/images/noahshin__11/post/b16c2d59-7395-481c-bd8d-f995dc096806/image.png)
디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징.
최대 테이블의 크기는 32TB이며 SQL뿐만 아니라 JSON을 이용해서 데이터에 접근할 수 있습니다. 
지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있습니다.

# 4.4.2 NoSQL 디비
Not Only SQL 슬로건에서 생겨난 디비
SQL 을 사용하지 않는 디비
MongoDB 와 redis 가 대표적
![](https://velog.velcdn.com/images/noahshin__11/post/4bdc4919-434b-4263-8257-cef6c77e178f/image.png)
MongoDB는 JSON을 통해 데이터에 접근할 수 있고, Binary JSON 형태(BSON)로 데이터가 저장되며 
와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스. 
확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고
고가용성과 샤딩, 레플리카셋을 지원. 
또한, 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석 하거나 로깅 등을 구현할 때 강점을 보입니다.

또한, MongoDB는 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 Objection 생성됩니다.
![](https://velog.velcdn.com/images/noahshin__11/post/e6112761-dda5-46b6-af69-9545a14d2a88/image.png)

## redis 

인메모리 디비이자 키-값 데이터 모델 기반의 디비

![](https://velog.velcdn.com/images/noahshin__11/post/2b86149f-8406-4099-aaef-20868e18a2f0/image.png)
기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장할 수 있습니다. 
이외에도 셋(set), 해시 (hash) 등을 지원합니다.
pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스에 사용합니다.












