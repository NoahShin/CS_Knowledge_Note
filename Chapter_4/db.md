# 데이터베이스

# 4.1 데이터베이스의 기본

## DBMS, DataBase Management System
![](https://velog.velcdn.com/images/noahshin__11/post/12fdac98-8bac-4bf3-bf07-74967e8abdfe/image.png)
응용프로그램: 노드 , 자바
DMBS : MySQL
데이터베이스: 창고(?)

## 4.1.1 엔터티
![](https://velog.velcdn.com/images/noahshin__11/post/4f02ef82-9309-4f77-9ffd-445dfc526ac0/image.png)

엔터티(entity)는 사람. 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미


#### 약한 엔터티와 강한 엔터티
- 엔터티는 약한 엔터티와 강한 엔터티로 나뉜다. 

- 예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티라고 할 수 있고 건물은 강 한 엔터티라고 할 수 있습니다.

## 4.1.2 릴레이션

- relation 은 디비에서 정보를 구분하여 저장하는 기본 단위.

- 엔터티에 관한 데이터를 디비는 릴레이션 하나에 담아서 관리.

![](https://velog.velcdn.com/images/noahshin__11/post/0e817e82-af21-4554-87b8-e55aad8c90dd/image.png)
위 그림처럼 회원이라는 엔터티가 
디비에서 관리될 때 
릴레이션으로 변화된 것을 볼 수 있다.

릴레이션은 RDBMS 에선 **테이블**
NoSQL 에선 **컬렉션**

## 4.1.3 속성

- Attribute 는 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보. 

"차"가 엔터티라면 
차 넘버, 바퀴 수, 차 색깔, 차종 등 속성

## 4.1.4 도메인
도메인이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합.

ex) 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값는 {남, 녀} 라는 집합.

## 4.1.5 필드와 레코드
![](https://velog.velcdn.com/images/noahshin__11/post/6f07f9f4-8ff0-4e46-9c2b-b667580b071b/image.png)

### 필드타입
(MySQL 기준)

#### 숫자타입
![](https://velog.velcdn.com/images/noahshin__11/post/3e4a4361-cb8f-4870-87fb-d87b98ea1db4/image.png)

#### 날짜 타입
> - **DATE**
날짜 부분은 있지만 시간 부분은 없는 값에 사용됩니다. 
지원되는 범위는 1000-01- 01〜9999-12-31입니다. 
3바이트의 용량을 가집니다.
- **DATETIME**
날짜 및 시간 부분을 모두 포함하는 값에 사용됩니다. 
지원되는 범위는 1000-01-01 00:00:00에서 9999-12-31 23:59:59입니다. 
8바이트의 용량을 가집니다.
- **TIMESTAMP**
날짜 및 시간 부분을 모두 포함하는 값에 사용됩니다. 
1970—01—01 00:00:01 에서 2038- 01-19 03:14:07까지 지원합니다. 
4바이트의 용량을 가집니다.


#### 문자 타입
> - CHAR
예를 들어 CHAR(30)이라면 최대 30글자까지 입력할 수 있습니다.
CHAR는 테이블을 생성할 때 선언한 길이로 고정되며 길이는 0에서 255 사이의 값을 가집니다. 레코드를 저장할 때 무조건 선언한 길이 값으로 ‘고정’해서 저장됩니다.
- VARCHAR
VARCHAR는 가변 길이 문자열입니다. 길이는 0에서 65,535 사이의 값으로 지정할 수 있으며, 입력된 데이터에 따라 용량을 가변시켜 저장합니다. 예를 들어 10글자의 이메 일을 저장할 경우 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 됩니다.
VARCHAR(10000)으로 선언했음에도 말이죠.

그렇기 때문에 지정된 형태에 따라 저장된 CHAR의 경우 검색에 유리하며, 검색을 별로
하지 않고 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋습니다.


#### TEXT 와 BLOB 
>- TEXT는 큰 문자열 저장에 쓰며 주로 게시판의 본문을 저장할 때 씁니다.
- BLOB은 이미지, 동영상 등 큰 데이터 저장에 씁니다. 그러나 보통은 아마존의 이미지 호 스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR 로 저장합니다.

#### ENUM 과 SET

ENUM과 SET 모두 문자열을 열거한 타입


> - ENUM은 ENUMfx—small’, ‘small’, ‘medium’, ‘large’, ‘x—large’) 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됩니다. ENUM을 이용하면 x-small 등이 0, 1 등으로 매핑되어 메모 리를 적게 사용하는 이점을 얻습니다. ENUM은 최대 65,535개의 요소들을 넣을 수 있습 니다.
- SET은 ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있으며 최대 64개의 요소를 집어넣을 수 있다는 점이 다릅니다.
참고로 ENUM이나 SET을 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수 정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점이 있습니다.


## 4.1.6 관계
![](https://velog.velcdn.com/images/noahshin__11/post/9233bc84-7733-48dd-b0b6-1cbf0e033b43/image.png)
위 그림만 봐서는 아는것도 모르겠다.

### 1:1 
![](https://velog.velcdn.com/images/noahshin__11/post/f4bea9ee-08db-423b-9b6d-e270bffea196/image.png)

### 1:N
![](https://velog.velcdn.com/images/noahshin__11/post/398fda3f-8ae9-4461-9dd4-d6887dc190da/image.png)

### N:M
![](https://velog.velcdn.com/images/noahshin__11/post/f0c5a6bd-d0c0-4eec-9ae8-e0cd81da4dc1/image.png)

## 4.1.7 키 
![](https://velog.velcdn.com/images/noahshin__11/post/69479560-dcf8-471a-8f6e-10556fdc2733/image.png)

### 기본키 PK 
당연히 중복 안됨

기본키는 자연키 또는 인조키 중에 골라 설정.

> **자연키**
예를 들어 유저 테이블을 만든다고 가정하면 주민등록번호, 이름, 성별 등의 속성이 있습 니다. 이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 남는 것은 주민 등록번호입니다. 이런 식으로 중복된 값들을 제외하며 중복되지 않는 것을 ‘자연스레’ 뽑 다가 나오는 키를 자연키라고 합니다. 자연키는 언젠가는 변하는 속성을 가집니다.

> 인조키
예를 들어 유저 테이블을 만든다고 했을 때 회원 테이블을 생성한다고 가정하면 주민등록 번호, 이름, 성별 등의 속성이 있습니다. 여기에 인위적으로 유저 아이디를 부여합니다. 이를 통해 고유 식별자가 생겨납니다. 오라클은 sequence, MySQL은 auto increment 등 으로 설정합니다. 이렇게 인위적으로 생성한 키를 인조키라고 합니다. 자연키와는 대조적 으로 변하지 않습니다. 따라서 보통 기본키는 인조키로 설정합니다.


### 외래키 FK

![](https://velog.velcdn.com/images/noahshin__11/post/11dc4de2-da92-4c11-83f1-4236e80f916d/image.png)

**후보키**
후보키 (candidate key)는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족 하는 키입니다.

**대체키**
대체키(alternate key)는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말합니다.

**슈퍼키**
슈퍼키(super key)는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키입니다.


# =================

# 4.2 ERD 와 정규화 과정

- ERD는 디비 구축할 때 가장 기초적인 뼈대 역할
- 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 **설계도** 역할

## 4.2.3 정규화 과정

### 제 1 정규형
릴레이션의 모든 도메인이 더 이상 분해될 수 없게
원자 값(atomic value)만으로 구성되어야 함.

릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 된다.

만약에 반복 집합이 있다면 제거해야 합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/f5e4ee7e-ed29-4860-8ac4-30222de9a570/image.png)


### 제 2 정규형
- 릴레이션이 제1정규형이면서
- 부분 함수의 종속성을 제거한 형태

부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다.
그러니까, 기본키 유저ID 홍철은 유저번호 1에 완전 종속적인 것

![](https://velog.velcdn.com/images/noahshin__11/post/59f05133-f1ad-44f4-90b4-924c06ff1032/image.png)

### 제 3 정규형

- 제2정규형이면서 
- 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태

> **이행적 함수 종속**
이행적 함수 종속이란 A — B와 B — C가 존재하면 논리적으로 A — C가 성립하는데, 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 합니다.
A = 유저ID 
B = 등급
C = 할인율
![](https://velog.velcdn.com/images/noahshin__11/post/4580df78-a870-4d5e-8d29-4eb160b71320/image.png)
![](https://velog.velcdn.com/images/noahshin__11/post/c3ef878f-c0d8-4dbb-ba6d-69a3d0285282/image.png)

### 보이스/코드 정규형 Boyce–Codd normal form (이해 불가)
보이스/코드 정규형(BCNF)은 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말합니다.
(뭔말이여)

![](https://velog.velcdn.com/images/noahshin__11/post/c71e1929-7c48-49a7-a9f2-bf70322f4ee5/image.png)

> 예시)
• 각 수강명에 대해 한 학생은 오직 한 강사의 강의만 수강한다.
• 각 강사는 한 수강명만 담당한다.
• 한 수강명은 여러강사가담당할수있다.

![](https://velog.velcdn.com/images/noahshin__11/post/57705ae1-8ab6-4a4f-aa0f-51b9bcde0951/image.png)


![](https://velog.velcdn.com/images/noahshin__11/post/4910b195-f5bf-416b-8742-37a58d34689c/image.png)
 즉, 강사 속성이 결정자이지만 후보키가 아니므로 이 강사 속성을 분리해야 합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/ed13ceb2-220d-4943-ac94-f6e22257dc65/image.png)


# 4.3 트랜잭션과 무결성

> - 디비에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 디비에 접근하는 방법은 쿼리이므로, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말함
- ACID ! 

## 원자성 “all or nothing”
 
> 원자성(atomicity)은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
예를 들어 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이 후에 모두 수행되지 않음을 보장하는 것


### 커밋과 롤백
커밋(commit)은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말합니다. 

“커밋이 수행 되었다.”를 “하나의 트랜잭션이 성공적으로 수행되었다.”라고 함
![](https://velog.velcdn.com/images/noahshin__11/post/c70b4d59-343e-4e9c-a090-76df63277ac4/image.png)
이러한 커밋과 롤백 덕에 데이터의 무결성이 보장 

또한, 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있.

#### 트랜잭션 전파
트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 합니다.

하지만 이를 매번 넘겨주기가 어렵기도 하고 귀찮기도 하죠. 

이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 합니다.
(자바코드라 그런지 모르겠음)
=============== ⚠️ 자바 ⚠️ =============== 
![](https://velog.velcdn.com/images/noahshin__11/post/d2e359f7-cced-489b-a263-f45d8341de46/image.png)
 앞의 코드처럼 Spring 프레임워크에서는 ©Transactional 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리

## 일관성
일관성(consistency)은 ‘허용된 방식’으로만 데이터를 변경해야 하는 것을 의미합니다. 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 합니다. 

## 격리성

격리성(isolation)은 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말합니다. 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 합니다. 그냥 순차적으로 하면 쉽게 되겠지만 그렇게 하면 성능이 나쁘겠죠?
격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/4bed63f1-d9bc-4aba-aa7e-b90d8bef190d/image.png)


> REPEATABLE_READ는 팬텀 리드, 
READ_COMMITTED는 팬텀 리드, 반복 가능하지 않은 조회가 발생하며. 
READ_UNCOMMITTED는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생할수도 있습니다.

도와줘요 ! :   https://velog.io/@moonyoung/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EB%A0%88%EB%B2%A8


도...도와줘 !! : https://velog.io/@pk3669/Mysql-Redo-Undo-Log

### 팬텀 리드
팬텀 리드(phantom read)는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다.
예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 해봅시다. 
이 결과로 세 개의 테이블이 조회한다고 해보죠. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입합니다. 그러면 그다음 세 개가 아닌 네 개의 테이블이 조회되는 것이죠.

### 반복 가능하지 않은 조회
반복 가능하지 않은 조회(non-repeatable read)는 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킵니다. 
예를 들어 사용자 A가 큰돌의 보석 개수가 100개라는 값을 가진 데이터였는데, 그 이후 사용자 B가 그 값을 1로 변경해서 커밋했다고 하면 사용자 A는 100이 아닌 1을 읽게 됩니다.
팬텀 리드와 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 
팬텀 리드는 **다른 행이 선택될 수도 있다는 것**을 의미합니다.

### 더티 리드
더티 리드(dirty read)는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 **‘커밋되지 않은’** 행의 데이터를 읽을 수 있을 때 발생합니다. 예를 들어 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 **‘커밋되지 않은’** 상태라도 그 이후 사용자 B가 조회한 결과가 1로 나오는 경우를 말합니다.

## 격리 수준

### SERIALIZABLE
SERIALIZABLE은 말 그대로 트랜잭션을 순차적으로 진행시키는 것을 말합니다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없습니다. 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 합니다. 그렇기 때문에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준입니다.

### REPEATABLE_READ
REPEATABLE_READ는 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않습니다. 따라서 이후에 추가된 행이 발견될 수도 있습니다.

### READ_COMMITTED
READ_COMMITTED는 가장 많이 사용되는 격리 수준이며 MySQL8.0, PostgreSQL, SQL Server, 오라클에서 **기본값으로 설정**되어 있습니다. READ UNCOMMITTED와 는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없습니다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용합니다.
하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있습니다. 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있습니다. 이 때문에 트랜잭션 A가 같 은행을 다시 읽을때 다른내용이 발견될 수 있습니다.

### READ_UNCOMMITTED
READ_UNCOMMITTED 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이 전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠릅니다. 이는 데이터 무결성을 위해 **되도록이면 사용하지 않는 것**이 이상적이나. 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 ‘어림잡아’ 집계하는 데는 사용하면 좋습니다.

## 지속성

지속성(durability)은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미. 
이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공.
![](https://velog.velcdn.com/images/noahshin__11/post/b9499a64-ac42-4070-ad8f-b7682e7cb03d/image.png)


# 4.4 데이터베이스의 종류
MySQL 제일 인기 많음

C, C++로 만들어졌으며 MylSAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 
매우 빠른 조인, 최대 64개의 인덱스를 제공합니다. 
대용량 데이터베이스를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공하며 많은 서비스에서 사용합니다.

### MySQL의 스토리지 엔진 아키텍처

![](https://velog.velcdn.com/images/noahshin__11/post/c293b3f5-46f4-4e16-9dad-4c57b0a0565d/image.png)

> 데이터베이스의 심장과도 같은 역할을 하는 곳이 바로 스토리지 엔진인데, 
모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점
스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용할 수 있음
또한, MySQL은 쿼리 캐시를 지원해서 입력된 쿼리문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시합니다.

### PostgreSQL
MySQL 다음으로 잘 나감
![](https://velog.velcdn.com/images/noahshin__11/post/b16c2d59-7395-481c-bd8d-f995dc096806/image.png)
디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징.
최대 테이블의 크기는 32TB이며 SQL뿐만 아니라 JSON을 이용해서 데이터에 접근할 수 있습니다. 
지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있습니다.

# 4.4.2 NoSQL 디비
Not Only SQL 슬로건에서 생겨난 디비
SQL 을 사용하지 않는 디비
MongoDB 와 redis 가 대표적
![](https://velog.velcdn.com/images/noahshin__11/post/4bdc4919-434b-4263-8257-cef6c77e178f/image.png)
MongoDB는 JSON을 통해 데이터에 접근할 수 있고, Binary JSON 형태(BSON)로 데이터가 저장되며 
와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스. 
확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고
고가용성과 샤딩, 레플리카셋을 지원. 
또한, 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석 하거나 로깅 등을 구현할 때 강점을 보입니다.

또한, MongoDB는 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 Objection 생성됩니다.
![](https://velog.velcdn.com/images/noahshin__11/post/e6112761-dda5-46b6-af69-9545a14d2a88/image.png)

## redis 

인메모리 디비이자 키-값 데이터 모델 기반의 디비

![](https://velog.velcdn.com/images/noahshin__11/post/2b86149f-8406-4099-aaef-20868e18a2f0/image.png)
기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장할 수 있습니다. 
이외에도 셋(set), 해시 (hash) 등을 지원합니다.
pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스에 사용합니다.



# 인덱스

## 인덱스의 필요성 


## B-트리

### 루프 노드 & 리프 노드

![](https://velog.velcdn.com/images/noahshin__11/post/41328ac3-bb93-457d-bf36-8061e32801f8/image.png)
예를 들어 E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라

E가 있을 법한 리프 노드로 들어가서 E를 탐색하면 쉽게 찾을 수 있죠. 

이 자료 구조 없이 E를 탐색하고자 하면 A, B, C, D, E 다섯 번을 탐색해야 하지만, 

이렇게 노드들로 나누면 두 번만에 리프 노드 에서 찾을 수 있습니다.





좀 더 자세한 예를 들어 보죠. 키 57에 해당하는 데이터를 검색해야 한다고 해봅시다.


![](https://velog.velcdn.com/images/noahshin__11/post/481108e8-529e-4f47-abce-c841c77f2d2c/image.png)

트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려옵니다. 
‘57보다 같거나 클 때까지〈=’
를 기반으로 처음 루트 노드에서는 39. 
83 이후 아래노드로내려와 46, 53, 57등 정렬된 값을 기반으로 탐색하는 것을 볼 수 있습니다.
이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 57이 가리키는 데이터 포인터를 통해 결괏값을 반환하게 됩니다.


#### 인덱스가 효율적인 이유와 대수확장성

인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문입니다.

대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미합니다. 

기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가합 니다.

![](https://velog.velcdn.com/images/noahshin__11/post/09c54ab4-287e-4836-8672-cb7c9a29bad3/image.png)
앞의 표처럼 트리 깊이는 열 개짜리로, 100만 개의 레코드를 검색할 수 있다는 의미입니 다. 참고로 실제 인덱스는 이것보다 훨씬 더 효율적이며, 그렇기 때문에 인덱스가 효율적 이라고 볼 수 있습니다.

## 4.5.3 인덱스만드는방법
인덱스를 만드는 방법은 데이터베이스마다 다르며 MySQL과 MongoDB를 기준으로 설
명합니다.

### MySQL

MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있으며. 
클러스터형 인덱스는 테이블당 하나를 설정할 수 있습니다. 
primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고, 
기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스 터형 인덱스로 만들 수 있습니다.

create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있습니다. 
하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋습니다.

### MongoDB
MongoDB의 경우 도큐먼트를 만들면 자동으로 ObjectID 형성되며,
해당 키가 기본키로 설정됩니다. 
그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있습니 다.

## 4.5.4 인덱스최적화기법

인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문 에 특정 데이터베이스를 기준으로 설명해도 무방합니다. 이 책에서는 MongoDB를 기반 으로 인덱스 최적화 기법을 설명하며, 이를 기반으로 다른 데이터베이스에 웬만큼 적용할 수 있습니다.


>1. 인덱스는 비용이다
먼저 인덱스는 두 번 탐색하도록 강요합니다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색 하기 때문이며, 관련 읽기 비용이 들게 됩니다.
또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 합니다. 마치 책의 본문이 수정되었 을 때 목차나 찾아보기도 수정해야 하듯이 말이죠. 이때 B-트리의 높이를 균형 있게 조 절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 됩 니다.
그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아닙니다. 또 한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적입니다.


>2. 항상 테스팅하라
인덱스 최적화 기법은 서비스 특징에 따라 달라집니다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이죠. 그렇기 때문에 항상 테스팅하는 것이 중요합니다. explainO 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간 을 최소화해야 합니다.
참고로 MySQL에서는 다음과 같은 코드로 테스팅을 수행합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/7360c011-b2b5-4c79-98d0-5ad54320a1cb/image.png)


>3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라집니다. 같음, 정렬, 다중 값, 카디 널리티 순으로 생성해야 합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/2fdf3dc5-c692-4376-b149-8be78ecec611/image.png)


# 조인의 종류

테이블을 묶는 것

참고로 MongoDB를 사용할 때 lookup은 되도록 사용하지 말아야 

![](https://velog.velcdn.com/images/noahshin__11/post/36626d7a-548d-4b56-9d5a-f12afc61a84e/image.png)



>- 내부 조인(inner join):왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 왼쪽 조인(left outer join):왼쪽 테이블의모든 행이결과 테이블에 표기
- 오른쪽 조인(right outer join):오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 합집합 조인(full outer join):두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표
기

어떻게 하시는지는 다들 SQL 잘 하시니까..

# 조인의 원리

## 4.7.1 중첩루프조인

중첩 루프 조인(NLJ, Nested Loop Join)은 중첩 for 문과 같은 원리로 조건에 맞는 조인 을 하는 방법이며, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사 용하지 않습니다.
예를 들어 “tl, t2 테이블을 조인한다.”라고 했을 때 첫 번째 테이블에서 행을 한 번에 하 나씩 읽고 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환합니다.

수도코드
![](https://velog.velcdn.com/images/noahshin__11/post/8a5fd2c7-99e6-42e9-b1bb-8169fe4397dc/image.png)
참고로 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인(BNL, Block Nested Loop)이라는 방식도 있습니다.

## 4.7.3 해시조인

해시 조인은 해시 테이블을 기반으로 조인하는 방법입니다. 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율 적입니다(메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생됩니다). 또한, 동등(=) 조인에서만 사용할 수 있습니다.

### 빌드단계
빌드 단계는 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계입니다.
예를 들어 persons와 countries라는 테이블을 조인한다고 했을 때 둘 중에 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드합니다.
![](https://velog.velcdn.com/images/noahshin__11/post/d46df9f2-b3c6-4d7a-b337-dd23d2bfa6c7/image.png)

### 프로브 단계

프로브 단계 동안 레코드 읽기를 시작하며, 각 레코드에서 ‘persons.coumry_id’에 일치하
는 레코드를 찾아서 결괏값으로 반환합니다.

![](https://velog.velcdn.com/images/noahshin__11/post/fcc4bcfc-5d82-49ce-83be-dff63b1a2433/image.png)

이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋습니다. 참고로 사용 가능한 메모리양은 시스템 변수 join_ bufifer_size에 의해 제어되며, 런타임 시에 조정할 수 있습니다.








